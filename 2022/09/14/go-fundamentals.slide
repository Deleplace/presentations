Go Fundamentals
2022-09-14

Valentin Deleplace
Happy path engineer for Google Cloud Platform
@val_deleplace

: Hello, my name is Valentin 
: I'm a Developer Advocate for Google Cloud, and I've been using Go as my daily programming language for over 8 years now.

* Warning

Some code will be displayed.

: Today I will show some Go code. But not only code.

* Overview of Go

.background ./go-fundamentals/hello.go.png

: For example, this is what a Hello World program looks like in Go.

: I suspect many of you already know this.

* About me 

#- Java web dev for 10+ years 
#- Discovered Go in 2012
#- Deployed Go apps on App Engine in 2013
#- Used Go for web development, command line tools, data processing...
#- Joined Google as a Cloud DA in 2017
#- ...and never stopped using Go as main daily language!

.image ./go-fundamentals/valentin.png 560 _


: A few words about myself!

: I've studied Computer Science and experimented with many languages.

: I've always had a preference for high-level, expressive languages that take care of memory management for me, and offer nice abstractions for concurrency, networking, etc.

: After using Java professionaly for many years, I pulled myself away from OOP and embraced Go, which was... different. Later in 2017, I joined Google Cloud as a Developer Advocate.

: If you follow me on Twitter, you'll see that I talk a lot about little-known aspects of the Go language, for example by asking trick questions in quizz polls.

* History of Go

- Designed at Google in 2007
- Version 1.0 released in 2012
- Version 1.18 released in 2022

: Go is not a new language anymore.

: It's been mature and ready for Production for many years now.

* Runtime

- Compiled to native code
- Statically typed
- Garbage collector
- Scheduler
- Not a VM

: Go is a compiled language. I can't overemphasize how precious it is for me to be Statically typed, and to have a GC.

: Static types mean that I can trust the arguments of my functions. Errors of typing are typically discovered during compilation, not at runtime when crashing or misbehaving.

: Garbage collection means that I can be more productive by not having to deal myself with proper deallocation.
: And automatic memory safety in general lets me avoid a large class of security vulnerabilities. I feel strongly about this fact: in most cases, manual memory management is just not worth it.

* What Go is for

.image ./go-fundamentals/go.dev.designed.png

: Go has become the de-facto language of cloud infrastructure.
: Think of Kubernetes, Docker, Istio, etc.

: But it's *also* an excellent general-purpose language.

* Go is a tool

: "Go is a tool" means that we should feel free to use it when appropriate, but not in a dogmatic way. 

: It plays nicely in heterogeneous environments, for examples micro-services using various technologies and languages.
: There's no reason to go "Full Go" and prevent your team from using another language. Just use the best tool for the job!

* Paradigms

Imperative?

- Yes.

Functional? 

- No.

Object-oriented? 

- No.

Generics? 

- ...Yes!

: Go clearly belongs to the family of the "C" language, like Java and C++, for the syntax and the imperative style.

: It's definitely not multi-paradigm, and so a Go codebase tends to keep some homogeneity.

: Generics have been conspicuously missing for over 10 years. They've been added in Go 1.18, which was released just a couple months ago.

* Principles

Simplicity

- Each language feature should be easy to understand.

Readability

- Code should be comprehensible with little context.

Orthogonality

- Go’s features should interact in predictable and consistent ways.
- Types ∟ Functions ∟ Goroutines ∟ Channels ∟ ...

: All new languages try to be as simple as possible. Go takes this concern very seriously by having a limited set of features, and making sure that all the features play nicely with each other.
: The language itself is almost "fixed", which means that the bar to add any new keyword or new concept to the language is extremely high.

* Goals

- Simplicity
- Scalability
- Stability: Go 1 compatibility promise
- Memory safety
- Good concurrency
- Good networking

: Here are a few core goals of the Go project as a whole (i.e. the language itself, the stdlib, the tooling, the philosophy, and the community).

: The language is extremely stable and backward compatible in the sense that a valid Go program written in 2022 will still be valid in 2030; you will still be able to compile it and execute it.

: Scalability is an important goal and it's multi-dimensional. It's about being able to leverage more CPU cores, more memory, more instances in a cloud environment, but also more teammates when the codebase grows.

* Genericity

- Built-in types *slice*, *map*, *chan* are generic
- *Interfaces* for generic behavior
- New (2022): type parameters

: For many years, it was surprising for developers coming from Java like me, that Go wouldn't let you define GENERIC types and generic functions.
: It turns out that most Gophers didn't miss generics that much, and were still able to write amazing software. Only a few use cases were really craving for generics, and these could usually be worked around with "interface{}" or with reflection, giving up compile-time type safety.
: But GENERICS are now available in the language! And my team has even been using this feature in a very specific case in the Google I/O Adventure backend, where workarounds were too awkward.

.background ./go-fundamentals/Invoice.png

* Objects

- No class inheritance
- Methods
- Composition, embedding
- Interfaces implicitly implemented

.code ./go-fundamentals/io.Reader.go

.code ./go-fundamentals/gzip.Reader.go

: Data structure types and processings are "orthogonal", with an emphasis on behaviors, rather than taxonomy. We're less interested in what objects *are*, and more interested in what objects *do*.

: Interfaces in Go are very similar to interfaces in Java. They are a powerful abstraction and can often be used in lieu of inheritance or generics.

* Concurrency

- Excellent support
- Goroutines are lighweight threads
- Message passing through channels

.image ./go-fundamentals/channel.jpg

: It is extremely useful that concurrency primitives are core to the language. Writing correct concurrent code is a difficult challenge in general, and it is made easier by Go's simple memory model, which is based on Tony Hoare's CSP (which stands for "Communicating Sequential Processes").

: Writing *sequential* code is fine, and most often it's the best thing to do. There exists several reasons why we may want to write concurrent code. For example, if we have some heavy computations to perform, and 64 CPU cores, then it makes sense to use many cores in parallel. But it's not always about the CPU! For example when a goroutine is writing to the filesystem, or waiting for a network response... then it's very useful to have other goroutines continue their work.

* Network

- Excellent standard library
- Creating a server is straightforward

.code ./go-fundamentals/simple-webapp.go

: The stlib comes "batteries included" when it comes to deploy HTTP handlers, generate JSON, etc.

: Writing an HTTP server is effectively just a few lines of code.

* Memory safety

- Bound checking
- Pointers
- ... no pointer arithmetic!
- Automatic garbage collection
- Avoids a large class of *bugs*
- Avoids a large class of *security* *leaks* 

: As I mentioned, Go is a memory-safe language, which is useful to prevent security vulnerabilities.
: You keep control of some important aspects of the memory layout of your objects. However, you can't access arbitrary memory beyond slice capacity, or via pointer value modification.

* Tradeoff

.image ./go-fundamentals/Language-speed-tradeoff.svg

: A language ecosystem always needs to make tradeoffs between conflicting goals.

: For example Go tends to be pretty good at these 3 kinds of "velocity", and in particular it has a super-fast compiler. 

#* Packages
#
#No cyclic dependency
#
#.background ./go-fundamentals/Package-dependency.svg

* Package management until 2018

No versioning

Breaking change == Make a new package for v2

Vendoring

: In the early days, package management was often achieved with vendoring.

: Vendoring consists of copying a dependency inside a subfolder of your project, keeping your build reproducible, and letting you plan to upgrade the dependency on your own schedule.

* Modules

Added in 2018

Semantic Versioning

Reproducible builds

Proxy (Athens)

: Then came Go modules. With modules, library authors have to follow the rules of semantic versioning. As a library user, you will typically let the tooling resolve the exact version of each dependency in order to satisfy your build.

* Cross-compilation

.background ./go-fundamentals/background-gopher-top-right.png

: Cross-compilation is one of my favorite features. 

* Cross-compilation

This is the compilation script of one of our tools *patapon*, run from my linux workstation:

	env GOOS=darwin  GOARCH=amd64 go build -o target/osx64/patapon
	env GOOS=darwin  GOARCH=arm64 go build -o target/osx64_m1/patapon
	env GOOS=windows GOARCH=amd64 go build -o target/win64/patapon.exe
	env GOOS=linux   GOARCH=amd64 go build -o target/linux64/patapon

*That's*it.*

To ship, copy the 4 executables to shared folder.

Executables are statically linked.

: This is an actual example from a few years ago (I just added 1 target for M1 processors). I'm writing a command line tool named "Patapon".

: Some of my colleagues have a Windows workstation, some have a Mac. And of course our production servers runs on Linux.

: When I compile Patapon, I need to ship a distinct executable for each of these platforms. No problem! From my workstation, or from any CI/CD tool, I can cross-compile to other target platforms with simple command lines.

#* Comparison with other languages
#
#* 
#
#.background ./go-fundamentals/comparison0.svg
#
#* 
#
#.background ./go-fundamentals/comparison1.svg
#
#* 
#
#.background ./go-fundamentals/comparison2.svg
#
#* 
#
#.background ./go-fundamentals/comparison3.svg
#
#* 
#
#.background ./go-fundamentals/comparison4.svg
#
#* 
#
#.background ./go-fundamentals/comparison5.svg
#
#* 
#
#.background ./go-fundamentals/comparison6.svg
#
#* 
#
#.background ./go-fundamentals/comparison7.svg
#
#* 
#
#.background ./go-fundamentals/comparison8.svg

* Philosophy

: A few more words about the philosophy of Go, and then I'll show some code. I promise!

* Less is more

- Short language spec
- Few keywords
- Few concepts
- Resist being everything for everyone

: "Less is more" means that a "smaller language" incurs a smaller cognitive burden to the developers, and enables them to be more productive.
: It means that having only extremely carefully designed language features, that play well with each other, enables the Go team at Google to keep improving the runtime, the GC, and the core stdlib.
: It means that some restrictions in how packages work (no cyclic dependency is possible) enable the compiler to be more performant.
: Etc.

* Clear is better than clever

- Readability matters
- Explicit loops
- Explicit error handling

: Go code is expected to be read by the compiler, but also by human peers (including yourself in 6 months). It's always formatted the same way, it's not always concise, it's sometimes repetitive, and even boring.

: And this is good, actually! Boring code does what it says it does. No surprises. And hopefully fewer bugs.

* No OOP

Focus less on clever hierarchy of types

- No inheritance
- Encourage composition 
- Embedding

Focus more on behavior 

- Interfaces

: As I already mentioned, Go is not what we usually call "Object-Oriented".
: You use simple data structures like slices and maps. You define methods on your types, and you implement interfaces. This is usually enough in terms of abstractions.

* No DRY 

Unlean the _Don't_ _Repeat_ _Yourself_ motto

"A little copying is better than a little dependency"

- Decoupled packages 
- No cycles in dependency graph
- Sometimes it's okay to copy and paste

: This one is a little surprising: We don't try too much to adhere to the "Don't Repeat Yourself" rule of thumb.
: Sometimes the same function will be written twice, for 2 slightly different types of arguments.
: Sometimes the same utility function will be copy-pasted in 2 different packages, in order to break a dependency relationship.
: There are always tradeoffs, and in Go we tend to lean towards as little *coupling* as possible.

* Concurrency

"Don't communicate by sharing memory, share memory by communicating"

- Channels

: This is an advice for proper concurrent programming. 
: It's tempting to regard the memory as a large whiteboard that goroutines will be allowed to read and write when they acquire locks (e.g. mutexes).
: But instead we are encouraged to write sequential agents managing their own local objects, and *sharing* them with other agents when needed, using channels.
: We'll talk about channels more in detail in a few minutes.

* Philosophy

.link https://go-proverbs.github.io/ go-proverbs.github.io

: You can find many bits of unexpected wisdom in this Go proverbs list on GitHub.



# -----------------------------------------------------------------------------

* The Expressiveness Of Go

.background ./go-fundamentals/background-gopher-top-right.png

: When we say that the Go language is expressive, what do we mean by that?
: It's of course about how much a developer can achieve with just a few lines of code. But it's definitely not just about being more concise or more verbose. It's more about how meaningful and legible is the code we write.
: I'll illustrate this with an example about how functions are used.

* First-class functions, and closures

.background ./go-fundamentals/background-gopher-top-right.png

: Go supports anonymous functions and closures. Let's have a look at a sample program.

* Simple chronometer

.play go-fundamentals/simple-chrono.go /START OMIT/,/END OMIT/

: I have a function *fetchData* and I want to know how much time it takes.
: The traditional way of doing this is to read the clock value just before the function is run, then again just after the function has executed, and substract the two values to compute the execution duration.
: What happens when I click the [Run] button is this: the source file will be compiled on my workstation (not inside the web browser), then executed, and the stdout/stderr will be displayed here, over the slide. So for now, it uses the Go toolchain that's installed on my system.
: Can you please CONFIRM that you see the output of the program? Otherwise I would need to share my screen in a different way.

* Simple chronometer: with func argument

.play go-fundamentals/simple-chrono2.go /START OMIT/,/END OMIT/,/START OMIT/,/END OMIT/

: We can encapsulate this logic in a function "clock" that takes a function as argument.
: Its job is to execute the function and return the execution duration.
: It accepts any function having this exact signature: zero arguments, and zero return values.
: This is similar to Javascript closures, but with compile-time safety.
: This is also similar to Java Runnables and Callables, but requires less boilerplate code.

* Chronometer: time a block of code?

	t := time.Now()

	for _, r := range resources {
		fetch(r)
	}

	duration := time.Since(t)

: Now if the instructions that I want to measure are not a function, but arbitrary lines of code, like this FOR loop.
: This is not a proper parameter for my "clock" function. What should I do?

* Wrap code in a closure

.play go-fundamentals/simple-chrono3.go /START OMIT/,/END OMIT/

: The solution is to create an anonymous function containing the loop, and pass it as an argument.
: It's important to be able to use anonymous functions on-the-fly like this, for scope reasons. It's not always possible to declare a new top-level named function that would have access to the same local variables of our current scope.
: Here it took 2s to fetch the resources SEQUENTIALLY. We'll see later about the opportunity to do this concurrently, to decrease the total latency for better performances.

* Expressiveness

- Type inference
- Explicit loops and conversions
- Multiple return values
- Slice syntax
- Map syntax
- 1 string type (UTF-8)
- Closures
- Goroutines
- Gofmt

: The following section is about the SYNTAX of Go code, which is not the most fundamental feature of the language, but is still very important for cognitive load, readability, and sustainability.

* Expressiveness

- *Type* *inference*

  a, b, ok := strings.Cut("en-US", "-")

: Here, we are not writing the type of the variables a, b, ok, because we expect CUT to return 2 strings and a boolean.
: Cut is similar to Split.
: The 1st string will receive "en", the 2nd string will be "US", and the boolean will be true, meaning "the DASH separator was found indeed in the 1st argument".

* Expressiveness

- *Type* *inference*

  a, b, ok := strings.Cut("en-US", "-")

.image go-fundamentals/doc-cut.png 

: This is the documentation of the Cut function in the strings package.
: You can see that Cut takes 2 arguments and returns 3 values.

* Expressiveness

- Type inference
- *Explicit* *loops* *and* *conversions*

Loop 

  for i := range salaries {
    salaries[i] += 100
  }

Conversion 

  var price int

  vat := float32(price) * 0.15

: Except for type inference, Go code tends to be very explicit, sometimes even boring.
: There are no magical functional syntactic sugar to iterate over a slice: just write a FOR loop. The intent and the consequences will be very clear to the reader.
: An int variable needs to be converted to a float in order to do floating-point computations. The conversion needs to be explicit in the code, no magic, no surprises.

* Expressiveness

- Type inference
- Explicit loops and conversions
- *Multiple* *return* *values*

  a, b, ok := strings.Cut("en-US", "-")

: As we've already seen, functions are not limited to return zero or one result. It is very common and useful to return several values.
: Actually, I'm surprised that this is not the standard in similar languages like Java and C++. I can take several inputs, why would it not be possible to compute several outputs?
: This is also extremely useful for error handling, because the idiomatic way to raise an error is to return an error value as last return parameter.

* Expressiveness

- Type inference
- Explicit loops and conversions
- Multiple return values
- *Slice* *syntax*

  week := []string{"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"}

  weekend := week[5:7]

  fishday := week[4]

  fantasyWeek := append(week, "caturday")

: Slices are very powerful and versatile dynamic arrays. It is a pleasure to use slicing, which creates a window to some part of the list.
: It takes a few days to learn and understand precisely how SLICES and APPEND work together. I really love this data structure.

* Expressiveness

- Type inference
- Explicit loops and conversions
- Multiple return values
- Slice syntax
- *Map* *syntax*

.play go-fundamentals/map-ops.go /START OMIT/,/END OMIT/

: Maps are another very powerful built-in type. They are associative arrays that map unique keys to some values. They are implemented as hashmaps under the hood, but we don't need to care about this implementation detail.
: Here you can see that the map OPS has keys of type STRING, and values of type FUNCTION THAT TAKES 2 INTS AND RETURN AN INT.
: I initialize the map with 4 arithmetic operations. It is very convenient to iterate over all the keys and values of the map with the RANGE keyword. The value OP is a function, which means of course that I can call the function OP inside the body of the loop.

* Expressiveness

- Type inference
- Explicit loops and conversions
- Multiple return values
- Slice syntax
- Map syntax
- *1* *string* *type* (UTF-8)

.play go-fundamentals/string-utf8.go /START OMIT/,/END OMIT/

: In Go, there is a single type for strings. Strings are very similar to immutable byte slices. UTF-8 is the default encoding. Each character is called a RUNE.
: The length of a string is always its number of bytes, however it may contain multi-byte characters. Here you can see, the string s has length 89, but it contains 43 runes.
: One needs to know some details about how UTF-8 works to figure out why some of these characters are displayed as 2 distinct runes.
: Strings supports slicing, which is efficient and safe, as all strings are immutable. Here, t contains the 7 first bytes of s.

* Expressiveness

- Type inference
- Explicit loops and conversions
- Multiple return values
- Slice syntax
- Map syntax
- 1 string type (UTF-8)
- *Closures*

  chomp := func(s string) string { return s[:len(s)-1] }
\...

  func clock(f func()) time.Duration {
      t := time.Now()
      f()
      return time.Since(t)
  }

: In Go, functions are first-class citizens, which is a fantastic feature for expressiveness. This is common in dynamic languages like JS, but less common in statically, strongly typed languages. Functions are strongly typed, they can be passed as arguments, and returned as values. Closures can freely access all of the variables in the scope where they are defined.
: We can do many things with METHODS and INTERFACES, but sometimes a FUNCTION variable is exactly what we need.

* Expressiveness

- Type inference
- Explicit loops and conversions
- Multiple return values
- Slice syntax
- Map syntax
- 1 string type (UTF-8)
- Closures
- *Goroutines*

: Goroutines are GREEN THREADS. They are similar to a Java thread of C++ thread, but more lightweight.
: It is cheap and idiomatic to create many goroutines for various tasks.

* Expressiveness

- Goroutines

.play go-fundamentals/goroutine-hello.go /START OMIT/,/END OMIT/

: The syntax reflects this and encourages you to launch a new goroutine, simply by preceding a function call by the keyword GO.
: CLICK RUN BUTTON — This is just a toy example, but in a real production usage, it is best to decide precisely when the Goroutine is supposed to stop, and how it will synchronize and communicate with other goroutines.
: The Go keyword, and the prowerful objects in the SYNC package, make it more straightforward to write correct concurrent code in Go, than in most other languages.

* Expressiveness

- Type inference
- Explicit loops and conversions
- Multiple return values
- Slice syntax
- Map syntax
- 1 string type (UTF-8)
- Closures
- Goroutines
- *Gofmt*

: GOFMT is the cherry on the top. Let's see what this is about...

* Gofmt

Unique code formatter

Nobody arguing about code formatting

.background ./go-fundamentals/mindblown.png

: Go has a unique code style formatter called GOFMT. Does it produce a good style?

: Yes. No. It doesn't matter! What matters is that **everybody** uses the same formatter,
: and **nobody** is wasting time convincing others about the best placement of the opening curly brace.

: _This_ turns out to be a huge productivity booster. I love it!

# -----------------------------------------------------------------------------

* Composition

.background ./go-fundamentals/background-gopher-top-right.png

# -----------------------------------------------------------------------------

* Error handling

.background ./go-fundamentals/background-gopher-top-right.png

: Proper error handling is always a source of passionate debates. What must we do when something goes wrong?

* Error handling: 2 types of errors 

"Expected": return values of type error

"Unexpected": panic

: Often, a program has a single and simple "happy path", when everything works as expected. The error cases can be much more diverse, not well understood, not well tested, and the appropriate strategy is very questionable.
: I will make a difference between what I call "expected" errors and "unexpected" errors.

* Error handling: 2 types of errors 

"*Expected*" errors: network requests failing, wrong user input

: Expected errors are something that can happen during the NORMAL execution of your program, because of external factors.
: When your program parses a user-provided file, it would be foolish to trust it at face value. You must validate the data and return an error value if the data is invalid.
: When your program calls a REST API, or a database, it would be foolish to think that it cannot fail. Your code must be prepared to retry, or to abort, any attempted network operation.
: All of this is part of the "normal program execution", IMO.
: If your program is a server, there is no good reason to crash the server because of one invalid request. Please handle the incorrect input *gracefully*.

* Error handling: 2 types of errors 

"Expected": network requests failing, wrong user input

"*Unexpected*": logic bug, init bug, hardware CPU/memory failure

: The other class of errors could be called "serious", or "critical", or "unchecked" in Java.
: If your program reaches an inconsistent state because of a bug in the program, then the error definitely falls into this category.
: A division by zero, an out-of-bounds slice access, are always caused by the programmer, not by invalid inputs, because inputs must always be validated before use.
: If the processor or the memory bus is failing, this is also not expected and not really recoverable.

* Expected errors

.play ./go-fundamentals/error-value.go /START OMIT/,/END OMIT/

: Any function that is expected to sometimes fail should return an error as its last return value.
: When this error is nil, this means that the function succeeded normally.
: When the error is not nil, it is the job of the call site to decide what to do with it.
: WALK THROUGH THE SAMPLE PROGRAM EXECUTION

* Expected errors

  err := f()
  if err != nil {
      return err
  }

: A lot has been said about Go error values to be verbose and tedious. Beginners complain about writing this exact pattern everywhere: CALL FUNCTION, TEST IF ERROR IS NON-NIL, RETURN THE ERROR TO THE CALLER
: I would say that programs gain from being very explicit and having programmable errors, at the cost of conciseness.
: But also the pattern on the screen is not the best practice: when an error occurs, we should either handle it right now, or wrap it in a more documented error before returning to the caller.

* Expected errors

.code ./go-fundamentals/wrapped-error.go

: This is such an example of wrapping an error.

* Expected errors

  type error interface {
      Error() string
  }

: The error built-in type is an interface with a single method, which is about providing an error message.
: Any custom type may implement the error interface.

* Expected errors

  type error interface {
      Error() string
  }
 
  type ResponseError struct {
    Message        string
    HTTPStatusCode int
    APIErrorCode   int
  }
  
  func (err ResponseError) Error() string {
    return fmt.Sprintf("(%d) handling request: %s", err.APIErrorCode, err.Message)
  }

: This is useful to provide rich errors with extra details to the caller function.
: The call site can either print a more comprehensible message to the user, or follow a retry policy depending on some specifics.
: Here for example, the server may send an error HTTP response with the appropriate Status Code, decided by some backend component.
: "ResponseError" is our custom error type. It implicitly implements the error interface, simply by having an Error method.

* Unexpected errors

panic

.play ./go-fundamentals/panic-divide-by-zero.go /START OMIT/,/END OMIT/

: Whenever the runtime encounters an unexpected error, such as an integer division by zero, it panics.

* Unexpected errors

panic

.play ./go-fundamentals/panic-out-of-bounds.go /START OMIT/,/END OMIT/

: It also panics when accessing an out-of-bound index in a slice.

* Unexpected errors

panic

.play ./go-fundamentals/panic-init.go

: If the program is not able to start because of incorrect initialization, it is also appropriate to panic.
: CLICK RUN BUTTON — As you can see, this program doesn't print Hello and Good bye. The Go program itself does compile successfully, however it crashes at runtime right here at initialization when trying to build the regex, even before entering the main function.
: Because backslashes have a special meaning, and this string is not a valid regex.

* Unexpected errors

panic

.play ./go-fundamentals/panic-custom.go /START OMIT/,/END OMIT/

: Whenever your code reaches an inconsistent state, you should also call the panic function.

* Unexpected errors

panic
recover

.play ./go-fundamentals/panic-recover.go /START OMIT/,/END OMIT/

: There exists 1 way to recover from an unexpected error that is panicking, and it is the builtin function *recover*. CLICK RUN BUTTON and WALK THROUGH EXECUTION
: panic and recover may look superficially like a try/catch control flow, however it is absolutely not a normal control flow.
: panics are serious events! Usually, panic is supposed to crash the program and display an error message.
: The only valid use case I know for using "recover" is when calling a function from a 3rd party library, which is known to be buggy and that you cannot fix because the code is not under your control. Then, it's okay to protect your server from a random panic from this library. Otherwise, please don't use recover for your usual control flow, it is not appropriate.

* Example: wrong offset in an archive

.code ./go-fundamentals/archive-wrong-offset.go

: Let's say your code is extracting files data from an archive (like a ZIP), but we're reaching an out-of-bounds offset, beyond the size of the whole archive.
: Should this be treated as an expected or unexpected error? Should we panic?
: We said that out-of-bound indexing would panic, which is what might happen here.
: But we also said that we should never trust user-provided inputs! We must treat this error as expected, and NOT let it panic.

* Example: wrong offset in an archive

.code ./go-fundamentals/archive-wrong-offset-explicit-checks.go

: Here is what some proper code would look like for such a parser.
: It is much more verbose, because whenever we're reading important data from the file, we explicitly test its validity and return an error.
: If the data is invalid, we'll catch it inside one of the checks, and gracefully return an error.
: When we're accessing data at a given index inside the slice, we're sure that it cannot panic, because we've already checked.

# -----------------------------------------------------------------------------

* Go for web, TCP, HTTP2/3, WebSockets

.background ./go-fundamentals/background-gopher-top-right.png

# -----------------------------------------------------------------------------

* Go for NodeJS Developers

.background ./go-fundamentals/background-gopher-top-right.png

# -----------------------------------------------------------------------------

* Channels

.background ./go-fundamentals/background-gopher-top-right.png

: Channels are one of the distinctive features of Go. They are a builtin mechanism that let goroutines talk to each other.

* Channels 

.image ./go-fundamentals/channel.jpg

- Communication device 
- Synchronization device

: Channels are "bidirectional pipes" for communication and synchronization. 

* Channels

.play ./go-fundamentals/channel-example.go /START OMIT/,/END OMIT/

: In this small example, we have 2 goroutines: the main goroutine, and a new goroutine started with the keyworg *go*. CLICK RUN BUTTON
: The 2 goroutines are using the same channel for reading and writing values. A goroutine that is reading the channel will block until some data is available.
: This is how we are sure that these 2 goroutines here are properly synchronized: the 1st value to be written to the channel MUST be "ping", then it is read here and printed, then the value "pong" is written, then it is read and printed here.
: What we just achieved is the communication of string messages, and the synchronization of 2 processes.

* Channels

2 modes: 

- Unbuffered (default). Writing is a blocking operation.
- Buffered. Writing is non-blocking, up to capacity.

: Depending on the use case, you will create your channels as either BUFFERED or UNBUFFERED.
: Unbuffered channels can be useful because any WRITE operation is BLOCKING until a READ operation is ready to process the message, and this is an interesting synchronization capability.
: With buffered channels, you can write several values without blocking. From a synchronization perspective, it works like a SEMAPHORE. From a communication perspective, it works like the PRODUCER/CONSUMER model of an assembly line. Buffered channels tend to be more efficient, for a few reasons.

* Channels: When to use them 

Producer-Consumer model

: What does a good producer-consumer use case look like?
: First, the producer is only supposed to WRITE to the channel, and the consumer is only supposed to READ. Second, it is the responsibility of the producer to close the channel when it doesn't have any more values to write. Third, it is the responsibility of the consumer to read and process all the messages, until the channel is closed.
: It is possible for the producer to fill a buffered channel with several messages that have not been processed yet. However, if the consumer is slow, the buffer will quickly become full, which will force the producer to slow down because each new WRITE will become a blocking operation.

* Channels: When to use them 

1 producer, 1 consumer

.image ./go-fundamentals/1-producer-1-consumer.png 240 _

: With exactly 1 goroutine acting as the producer, and 1 goroutine acting as the consumer, everything is pretty simple and smooth.
: For example, I could have 1 goroutine that scans my filesystem for all files and write their path to a channel, and 1 goroutine that computes the SHA-256 digest of all of the files.
: Each of the 2 worker goroutines does its own work at its own pace, except when the consumer has nothing to READ, or when the producer cannot WRITE because it has already filled the buffer.

* Channels: When to use them 

1 producer, N consumers

.image ./go-fundamentals/1-producer-N-consumers.png 240 _

: Now imagine that computing cryptographic hashes is EXTREMELY CPU-intensive, and your machine has 64 CPU cores. Then it makes perfect sense to launch dozens of consumer goroutines, all feeding on the SAME channel until exhaustion.
: Each message is guaranteed to be read by exactly 1 consumer worker.
: The whole system is still pretty simple: the producer writes values and then closes the channel, and all the workers are doing the SAME range loop over the SAME channel until closed, as if it were a sort of PULL QUEUE.

* Channels: When to NOT use them 

M producers, 1 consumer

.image ./go-fundamentals/M-producers-1-consumer.png 240 _

: Things get more complicated as soon as we have several producers. For example, if reading from the filesystem if EXTREMELY SLOW but paralellizable, then we would love to launch several producer goroutines, each traversing a different sector of the hard drive concurrently.
: Unfortunately, it is NOT STRAIGHTFORWARD to use a channel for this. The different producers would need to synchronize with each other, using yet other primitives in order to agree about when to close the channel.

* Channels: When to NOT use them 

M producers, N consumers

.image ./go-fundamentals/M-producers-N-consumers.png 240 _

: Likewise, having M producers talk to N consumers is difficult, but only because of the producers' side.

* Channels: When to use them 

- *Fan-in* pattern: enables merging M producers

.image ./go-fundamentals/fan-in.png 240 _

: It is still possible, but more complicated, to have several producers write to their own channel, and merge these input channels into one.
: This is called a "FAN-IN". It is a bit subtle to implement correctly. It would allow to traverse the filesystem concurrently, to discover all the files to be hashed.

* Channels: When to use them 

- *Fan-out* pattern: enables broadcasting messages to all of the N consumers
- Also, closing a channel broadcasts a signal to all the readers

.image ./go-fundamentals/fan-out.png 240 _

: It is also possible to duplicate the same messages to several consumers.
: This is called a "FAN-OUT". For example, you may want to compute the SHA-256 hash of the files, but also the SHA-512 hash of the same files, and also the MD5 hash, all done concurrently by different goroutines.

* Channels: When to NOT use them 

In an API: 

- as an argument of a func/method
- as an return parameter of a func/method

: I would advise AGAINST using a channel to provide streams of input and output data in an API.
: It is tempting, but in practice it creates unnecessary complexity related to the lifecycle of the channel.
: The rule of thumb is: don't force concurrency behaviours to your callers. Just expose a sequential API, and let the callers use concurrency on their side if they need to.

* Channels: When to NOT use them 

Fork/Join

- For this, use a WaitGroup

: If you're tempted to use a channel for the purpose of synchronizing the completion of several independent tasks, then you're also creating unnecessary complexity.
: For this, prefer using a WaitGroup from the SYNC package.

* Channels: When to NOT use them 

Fork/Join

- For this, use a WaitGroup 

.play ./go-fundamentals/waitgroup-sha256.go /START OMIT/,/END OMIT/

: Let's run this WaitGroup example — CLICK RUN BUTTON
: As demonstrated here, a WaitGroup is more readable for this purpose. You create a WaitGroup with the appropriate number of tasks, and then your main goroutine calls WAIT to block until the worker goroutines are finished.

# -----------------------------------------------------------------------------

* Optimizing for maximum efficiency

.background ./go-fundamentals/background-gopher-top-right.png

: Performance optimization! This is a fascinating topic, and also a surprisingly SUBJECTIVE topic, in my experience.

* 

.background ./go-fundamentals/perf-tricks.svg

: Here is a quick checklist of common performance bottlenecks, and how we can address them in Go

* 

.background ./go-fundamentals/perf-tricks_1.svg

: What should you do if your code is already fast?

* 

.background ./go-fundamentals/perf-tricks_2.svg

: I strongly recommend not to optimize too early, and not to try to optimize everything. 
: And above all: don't turn your code into a giant spaghetti monster just for the sake of performance. Please don’t.

* 

.background ./go-fundamentals/perf-tricks_3.svg

: However if your code is not fast enough, then look at the ever-popular execution of useless instructions!

* 

.background ./go-fundamentals/perf-tricks_4.svg

: Obviously, hunting and eliminating useless code is a good thing. Please do it.

* 

.background ./go-fundamentals/perf-tricks_5.svg

: The Big-O of a function is its theoretical computational complexity.
: Big-O analysis is the golden metric at the university, and also in some job interviews.

* 

.background ./go-fundamentals/perf-tricks_6.svg

: In my experience however, Big-O is not always helpful, and can even be misleading.
: Of course, if your function is quadratic or cubic, then you probably won't be able to go very far, and a better algorithm will be needed. However in my experience, dirty slow code and clean efficient code often have the exact same time complexity.
: The real difference is how the efficient code successfully gets rid of all the clutter, that we commonly sweep under the carpet of "irrelevant hidden multipliers".

* 

.background ./go-fundamentals/perf-tricks_7.svg

: Network I/O, external API calls, and database requests, are relatively extremely expensive.

* 

.background ./go-fundamentals/perf-tricks_8.svg

: My advice is to:
: - make as few requests as possible,
: - and not to block everything while waiting for a network response
: - consider batching, which is about providing several inputs to a service at the same time, and quickly receiving several responses.

* 

.background ./go-fundamentals/perf-tricks_9.svg

: Reading from the filesystem, and writing to the filesystem, is slower than most of what we do in memory and in the CPU.

* 

.background ./go-fundamentals/perf-tricks_10.svg

: My advice is:
: - To work as much as you can IN MEMORY
: - And to do your I/O in a non-blocking way! When one goroutine is busy reading from the disk, then the other goroutines still have ample opportunity to do some useful work.

* 

.background ./go-fundamentals/perf-tricks_11.svg

: Contention!
: Thousands of goroutines waiting for each other is a perfect recipe for unnecessary slowness.

* 

.background ./go-fundamentals/perf-tricks_12.svg

: To limit the excessive need for constant communication between goroutines, I suggest to create workers.
: The worker pattern looks like this: If I have 4 CPU cores and 1M computations to perform…
: Technically I *could* launch 1M goroutines, which would have a cost in scheduling and in synchronization to gather the results.
: But it’s more efficient to start a small number of worker goroutines, say 8, and have each worker process one 8th of the total load sequentially.

* 

.background ./go-fundamentals/perf-tricks_13.svg

: Asking for memory to the operating system and to the Go runtime is a notoriously slow operation.

* 

.background ./go-fundamentals/perf-tricks_14.svg

: My advice is to:
: - Allocate large chunks of memory in one single call to the built-in “make” function
: - Reuse memory by passing buffers as arguments to the processing functions. This is called BYOB — Bring Your Own Buffer.
: - Also, sometimes using a Pool from the sync package can prove very useful.


* 

.background ./go-fundamentals/perf-tricks_15.svg

: For example, allocating UPFRONT is more efficient than allocating many times with append in a loop.
: (EXPLAIN HOW DYNAMIC ARRAY WORKS HERE)

* 

.background ./go-fundamentals/perf-tricks_16.svg

: Heap or Stack?
: This part is specific to the Go compiler. We know that allocating in the heap is expensive (relatively), and that allocating on the stack is almost free. But what goes to the heap, and what goes to the stack?
: The answer is not intuitive. Some local variable may escape to the heap if we take its reference and pass it around.


* 

.background ./go-fundamentals/perf-tricks_17.svg

: the Go specification does not say anywhere if memory is allocated on the stack or in the heap. In fact, the spec contains zero occurrence of the words “stack” and “heap”.
: In the end, it depends if the compiler is clever enough to prove that a variable doesn’t escape, so it is safe to put it on the stack.
: Use this extra gcflag to determine which local variables escape or not. You may then try to adapt the function scope to "leak" fewer references.


* 

.background ./go-fundamentals/perf-tricks_18.svg

: Regular expressions are great and very powerful. But they are often overkill for a given need.

* 

.background ./go-fundamentals/perf-tricks_18b.png

: In this example, extracting words separated by a slash is MORE LEGIBLE and MORE EFFICIENT if we use the standard function strings.Split, instead of a regular expression.

* 

.background ./go-fundamentals/perf-tricks_19.svg

: My advice, from the performance POV, is basically to avoid Regular Expressions when you can.
: You can often get better results using the standard packages strings and bytes, or writing your own for loop.

* 

.background ./go-fundamentals/perf-tricks_20.svg

: A function call incurs a non-zero cost, which can be significant if the function is very small, and called millions of times.
: The compiler is able to INLINE some small functions, which means to COPY-AND-PASTE THE BODY of the function, instead of actually making a function call.

* 

.background ./go-fundamentals/perf-tricks_20b.png

: This function on the left will NOT BE INLINED.
: But if you as a developer write this equivalent function on the right, then the compiler will INLINE it, effectively saving the cost of a function call, and potentially enabling other awesome compiler optimizations as well.

* 

.background ./go-fundamentals/perf-tricks_21.svg

: The language specification does not talk at all about inlining.
: The compiler has its own very specific internal rules when it comes to decide if a small function will be inlined or not.
: Chasing the inliner, to have it inline a specific hot function, has become a popular sport! 



# -----------------------------------------------------------------------------

* Go GC

.background ./go-fundamentals/background-gopher-top-right.png

: The Garbage Collector.
: It is so awesome, that there's really not much to say about it.
: If you have a background in an interpreted language like Javascript, Python, or Java, the principle is the same: You don't have to explictly free the memory yourself.
: If you come from C or C++, you can consider the GC 

* Garbage Collector

- Doesn't get in your way 
- Runs concurrently
- Very short Stop-The-World pauses (<1ms)

: TODO COMMENT

* Garbage Collector

TODO TODO

TODO DISPLAY AND EXPLAIN THE DIAGRAM DENTS DE SICE https://tip.golang.org/doc/gc-guide

: TODO COMMENT

# -----------------------------------------------------------------------------

* Go profiling (Pprof)

.background ./go-fundamentals/background-gopher-top-right.png

* Thank you :)

#.background ./go-fundamentals/background_QR-twitter.png

Valentin Deleplace

Happy path engineer for Google Cloud

Twitter @val_deleplace

Medium @val_deleplace

GitHub @Deleplace

This presentation:
.link https://talks.godoc.org/github.com/Deleplace/presentations/2022/09/14/go-fundamentals.slide talks.godoc.org/github.com/Deleplace/presentations/2022/09/14/go-fundamentals.slide
