<h1>Hello, GoSheffield!</h1>

<h2>Function inlining</h2>
<h4><em>or</em></h4>
<h3><i>How to make friends and influence the compiler</i></h3>

<speaker-notes>
    This talk is about a rather low-level concern in the assembly code 
    generated by the Go compiler, which results in programs executing
    slightly slower or slightly faster.
</speaker-notes>
---
<h1>What is inlining?</h1>

<split-view>
    <source-code folder="illustration"
        files="before.go"
        start-lines="5"
        end-lines="7">
    </source-code>
    <div></div>
    <div></div>
</split-view>


<speaker-notes>
    It's when the compiler decides to move the instructions of the body 
    of a function... 
</speaker-notes>
---

<h1>What is inlining?</h1>

<split-view>
    <source-code folder="illustration"
        files="before.go"
        start-lines="5"
        end-lines="7">
    </source-code>
    <div class="fat-arrow">
        →
    </div>
    <source-code folder="illustration"
        files="after.go"
        start-lines="11"
        end-lines="11">
    </source-code>
</split-view>


<speaker-notes>
    ...inside the body of the calling function.
    <br/>
    In this example, func <b>square</b> is no longer useful, as it
    was called by only one function, and it just got inlined.
</speaker-notes>
---
<h1>Why?</h1>

<ul class="list">
    <li>
        Overhead of a function call
        <ul>
            <li>Copy parameters into registers</li>
            <li>Copy parameters to the stack</li>
            <li>Dynamic stack growth</li>
            <li>Jump</li>
            <li>Function prologue</li>
        </ul>
    </li>
</ul>

<speaker-notes>
    Inlining is beneficial for performance, as there is quite a lot of 
    work related to <b>calling a function</b> that no longer needs to be
    done.
</speaker-notes>
---
<h1>Why?</h1>

<ul class="list">
    <li>
        Inlining enables further optimizations
        <ul>
            <li>Constant propagation</li>
            <li>Bound check elimination</li>
            <li>Dead code elimination</li>
            <li>Hoisting <i>(Loop-invariant code motion)</i></li>
        </ul>
    </li>
</ul>

<speaker-notes>
    Even more interestingly in my opinion, coupling the <b>callee</b> func body with the 
    <b>caller</b> func body unlocks other optimization strategies.
    <br/>
    ...........
</speaker-notes>
---
<h1>Why?</h1>

<ul class="list">
    <li>
        Inlining enables further optimizations
        <ul>
            <li>Constant propagation</li>
            <li>Bound check elimination</li>
            <li>Dead code elimination</li>
            <li>Hoisting <i>(Loop-invariant code motion)</i></li>
        </ul>
    </li>
</ul>

<speaker-notes>
    Basically, a regular function can only make limited assumptions about the expected
    runtime call stack. But when it's inlined, it suddenly has much more information
    about the specific values of its arguments, and about the shape of the caller's 
    control flow.
</speaker-notes>
---
<h1>Tradeoff</h1>

<img src="images/inlining_chart.png" />

<speaker-notes>
    Should we just inline all functions? Well, no.
    <br/> 
    1st: it's not always possible, e.g. inlining a recursive func doesn't 
    really make sense, except if we somehow limit its depth
    <br/>
    ...........
</speaker-notes>
---
<h1>Tradeoff</h1>

<img src="images/inlining_chart.png" />

<speaker-notes>
    .....2nd: each inlining tends to make the executable binary larger.
</speaker-notes>
---

<h1>Secret directive</h1>

<split-view>
    <source-code folder="a"
        files="inlining_test.go"
        start-lines="5,16"
        end-lines="7,18">
    </source-code>
    <web-term path="a"></web-term>
</split-view>

<speaker-notes>
    Here is a trivial function which computes the square of an integer.
    There are 2 identical implementations, 2nd one having pragma "noinline".
</speaker-notes>
---

<h1>Inlining ≡ copy-pasting func body</h1>

<split-view>
    <img src="images/a_with_square1.png">
    <div></div>
    <div></div>
    <div></div>
</split-view>


<speaker-notes>
</speaker-notes>
---

<h1>Inlining ≡ copy-pasting func body</h1>

<split-view>
    <img src="images/a_with_square1.png">
    <div class="fat-arrow">
        →
    </div>
    <img src="images/a_without_square1.png">
    <div></div>
</split-view>


<speaker-notes>
    The code flow was effectively transformed, into an equivalent
    program where func square1 doesn't exist.
</speaker-notes>
---

<h1>Diminishing returns</h1>

<split-view>
    <web-term path="b"></web-term>
    <source-code folder="b"
        files="inlining_test.go"
        start-lines="5,40"
        end-lines="5,40">
    </source-code>
</split-view>

<speaker-notes>
    Now if your function is larger <b>and</b> still gets inlined, then
    the perf gain will be a smaller % of the func execution time.
</speaker-notes>
---

<h1>Large functions</h1>

<split-view>
    <source-code folder="c"
        files="inlining_test.go"
        start-lines=""
        end-lines="">
    </source-code>
    <web-term path="c"></web-term>
</split-view>

<speaker-notes>
    Now if your function is even larger, then the perf gain is zero.
    That's because it's not inlined at all.
    And there exist no directive to force inlining.
</speaker-notes>
---

<h1>Func splitting</h1>

<split-view>
    <web-term path="d"></web-term>
    <source-code folder="d"
        files="inlining_test.go"
        start-lines=""
        end-lines="">
    </source-code>
</split-view>

<speaker-notes>
    The developer may decide to cut a long func into 
    smaller funcs, in the hope that they will be
    individually inlined.
</speaker-notes>
---

<h1>Multiple level inlining</h1>

<split-view>
    <source-code folder="e"
        files="inlining_test.go"
        start-lines="13"
        end-lines="17">
    </source-code>
    <web-term path="e"></web-term>
</split-view>

<speaker-notes>
    If nested funcs are inlined, then the compiler may 
    further inline the caller funcs themselves!
</speaker-notes>
---

<h1>Multiple level inlining</h1>

    <split-view>
        <img src="images/e.png">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </split-view>

<speaker-notes>
    Here, 3 trivial funcs...
</speaker-notes>
---

<h1>Multiple level inlining</h1>

    <split-view>
        <img src="images/e.png">
        <div class="fat-arrow">
            →
        </div>
        <img src="images/e_bis.png">
        <div></div>
        <div></div>
        <div></div>
    </split-view>

<speaker-notes>
    ...are turned into 1 trivial func...
</speaker-notes>
---

<h1>Multiple level inlining</h1>

    <split-view>
        <img src="images/e.png">
        <div class="fat-arrow">
            →
        </div>
        <img src="images/e_bis.png">
        <div class="fat-arrow">
            →
        </div>
        <img src="images/e_ter.png">
        <div></div>
    </split-view>

<speaker-notes>
    ...and then no trivial func at all.
</speaker-notes>
---

<h1>panic</h1>

<split-view>
    <web-term path="f"></web-term>
    <source-code folder="f"
        files="inlining_test.go"
        start-lines=""
        end-lines="">
    </source-code>
</split-view>

<speaker-notes>
    square1 is complex or "hairy" because it may call <b>panic</b>. 
    Such funcs couldn't be inlined, but now they can
    since ...(demo)... Go 1.11.
</speaker-notes>
---

<h1>Mid-stack inlining</h1>

<split-view>
    <source-code folder="g"
        files="inlining_test.go"
        start-lines=""
        end-lines="">
    </source-code>
    <web-term path="g"></web-term>
</split-view>

<speaker-notes>
    The compiler used to inline only <b>leaf</b> funcs, i.e. funcs
    that don't call any complex non-inlined funcs.
    This example is now inlined since (...demo...) Go 1.12.
    Some runtime magic takes care of the original call stack, in 
    case it's needed for debug or other purpose.
</speaker-notes>
---

<h1>Dead code elimination</h1>

<split-view>
    <web-term path="h"></web-term>
    <source-code folder="h"
        files="inlining_test.go"
        start-lines=""
        end-lines="">
    </source-code>
</split-view>

<speaker-notes>
    A powerful benefits of inlining is enabling other 
    compiler optimizations. E.g. turning a func parameter into 
    a known value may eliminate a whole <i>if</i> block,
    whose condition is always false.
</speaker-notes>
---

<h1>Unrolling</h1>

<split-view>
    <source-code folder="i"
        files="inlining_test.go"
        start-lines="10,26,42,57"
        end-lines="12,28,44,57">
    </source-code>
    <web-term path="i"></web-term>
</split-view>

<speaker-notes>
    Explain: <i>cannot inline grey1: unhandled op RANGE</i>. 
    <br/>
    Why grey3 is faster: BCE (bound check elimination).
    <br/>
    <b>randomColor</b> not inlined (too complex, over budget)
    <br/>
    The "budget" is an arbitrary measure of "hairiness"/complexity.
</speaker-notes>

---

<h1>Unrolling</h1>

<split-view>
    <source-code folder="j"
        files="inlining_test.go"
        start-lines="57"
        end-lines="57">
    </source-code>
    <web-term path="j"></web-term>
</split-view>

<speaker-notes>
    Now if <b>randomColor</b> returns a slice of constant byte values,
    it's now simple enough to be inlined. Yay!
    <br/>
    But why have we "lost" the perf gain of <b>grey3</b>?
</speaker-notes>

--- 

<h1>Inlining: Take-away</h1>

<ul class="take-away">
    <li>Don't worry too much about it</li>
</ul>

<speaker-notes>
    It's intentional that <b>Inlining</b> is more of a compiler concern 
    and less of a developer concern.
    <br/>
    There is no flag/directive/pragma to force inlining.
</speaker-notes>

--- 

<h1>Inlining: Take-away</h1>

<ul class="take-away">
    <li>Don't worry too much about it</li>
    <li>The compiler is quietly improving</li>
</ul>

<speaker-notes>
    The Go team is working on improving the compiler and the 
    runtime for you.
    <br/>
    Sometimes using the newest Go version will enable more 
    func inlining, among other optimizations.
</speaker-notes>

--- 

<h1>Inlining: Take-away</h1>

<ul class="take-away">
    <li>Don't worry too much about it</li>
    <li>The compiler is quietly improving</li>
    <li>Focus only on smallish funcs <b>in your hot path</b></li>
</ul>

<speaker-notes>
    If your func is <b>not</b> called millions of times in your 
    innermost loop, then don't bother chasing the inliner.
    <br>
    The perf gain would be negligible.
</speaker-notes>

--- 

<h1>Inlining: Take-away</h1>

<ul class="take-away">
    <li>Don't worry too much about it</li>
    <li>The compiler is quietly improving</li>
    <li>Focus only on smallish funcs <b>in your hot path</b></li>
    <li>Consider writing smaller funcs (within complexity budget)</li>
</ul>

<speaker-notes>
    It is possible to nudge the compiler by splitting your funcs into pieces,
    in the hope that some pieces will get inlined.
</speaker-notes>

--- 

<h1>Inlining: Take-away</h1>

<ul class="take-away">
    <li>Don't worry too much about it</li>
    <li>The compiler is quietly improving</li>
    <li>Focus only on smallish funcs <b>in your hot path</b></li>
    <li>Consider writing smaller funcs (within complexity budget)</li>
    <li>Consider unrolling a small loop</li>
</ul>

<speaker-notes>
    It is also possible to trick the compiler by avoiding complex 
    constructs, like the <i>for-range</i> loop.
    <br/>
    However, think twice before writing peculiar, difficult to read code. 
    Most of the time <b>legibility</b> is more valuable than performance.
</speaker-notes>

--- 

<h1>Slides with terminal-based demo</h1> 

<h2><span class="grey">github.com/dgageot/</span>demoit</h2>

<speaker-notes>
    Before I finish I'd like to thank my colleague David Gageot for his 
    wonderful presentation tool Demoit, which I'm using right now.
</speaker-notes>
--- 

<h1>Thank you :)</h1>
<h4>Valentin Deleplace</h4>
<h4>Developer Advocate, Google Cloud</h4>
<h4>I'm on Twitter: <b>@val_deleplace</b></h4>

<speaker-notes>
    That's it for today! You may contact me on Twitter if you like.
</speaker-notes>